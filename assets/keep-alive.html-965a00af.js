import{_ as e,p as n,q as a,Z as s}from"./framework-87c4c4c1.js";const o={},c=s(`<h1 id="对keep-alive的理解" tabindex="-1"><a class="header-anchor" href="#对keep-alive的理解" aria-hidden="true">#</a> 对keep-alive的理解</h1><hr><p><strong>是什么</strong><code>keep-alive</code>是<code>vue</code>中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染<code>DOM</code><code>keep-alive</code>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们</p><p><code>keep-alive</code>可以设置以下<code>props</code>属性：</p><ul><li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存</li><li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存</li><li><code>max</code> - 数字。最多可以缓存多少组件实例</li></ul><p>设置了<code>keep-alive</code>缓存的组件，会多出两个生命周期钩子（<code>activated</code>和<code>deactivated</code>） 首次进入组件时：<code>beforeCreate</code>-&gt;<code>created</code>-&gt;<code>beforeMount</code>-&gt;<code>mounted</code>-&gt;<code>activated</code> 再次进入组件时：<code>activated</code></p><p><strong>使用场景</strong> 当我们在某些场景下不需要让页面重新加载时我们可以使用<code>keep-alive</code> 例：从<code>**首页**</code><strong>-&gt;</strong><code>**列表页**</code><strong>-&gt;</strong><code>**商品详情页**</code><strong>-&gt;</strong><code>**再返回**</code>，这时候<code>**列表页**</code>应该是需要<code>keep-alive</code></p><p><strong>缓存后如何获取数据</strong> 解决方案有两种：</p><ol><li>beforeRouteEnter</li><li>actived</li></ol><p><code>**beforeRouteEnter**</code> 每次组件渲染的时候，都会执行<code>beforeRouteEnter</code></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">beforeRouteEnter</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token parameter">vm</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    <span class="token comment">// 每次进入路由执行</span>
    vm<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 获取数据</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>**actived**</code> 在<code>keep-alive</code>缓存的组件被激活的时候，都会执行<code>actived</code>钩子</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token function">activated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   this<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 获取数据</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,13),t=[c];function p(d,i){return n(),a("div",null,t)}const u=e(o,[["render",p],["__file","keep-alive.html.vue"]]);export{u as default};
