import{_ as e,p as r,q as t,Z as o}from"./framework-87c4c4c1.js";const s="/imgs/source/sex.jpeg",n={},c=o('<h1 id="vue双向绑定的原理" tabindex="-1"><a class="header-anchor" href="#vue双向绑定的原理" aria-hidden="true">#</a> vue双向绑定的原理</h1><hr><p><strong>原理</strong> Vue数据双向绑定原理是通过数据劫持结合发布者-订阅者模式的方式来实现的，首先是对数据进行监听，然后当监听的属性发生变化时则告诉订阅者是否要更新，若更新就会执行对应的更新函数从而更新视图</p><p><strong>深入</strong> 首先要对数据进行劫持监听，所以我们需要设置一个监听器 <strong>Observer</strong>，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者 <strong>Watcher</strong> 看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器 <strong>Dep</strong> 来专门收集这些订阅者，然后在监听器 <strong>Observer</strong> 和订阅者** Watcher **之间进行统一管理的。接着，我们还需要有一个指令解析器 <strong>Compile</strong> ，对每个节点元素进行扫描和解析，将相关指令（如 **v-model，v-on **）对应初始化成一个订阅者 <strong>Watcher</strong> ，并替换模板数据或者绑定相应的函数，此时当订阅者 **Watcher **接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。</p><ul><li>（1）实现一个监听器 <strong>Observer</strong>，用来劫持并监听所有属性，如果有变动的，就通知订阅者。</li><li>（2）实现一个订阅者 <strong>Watcher</strong>，每一个 **Watcher **都绑定一个更新函数，**watcher **可以收到属性的变化通知并执行相应的函数，从而更新视图。</li><li>（3）实现一个解析器 <strong>Compile</strong>，可以扫描和解析每个节点的相关指令（v-model，v-on等指令），如果节点存在v-model，v-on等指令，则解析器Compile初始化这类节点的模板数据，使之可以显示在视图上，然后初始化相应的订阅者（Watcher）。</li></ul><p><img src="'+s+'" alt="sex"></p>',6),a=[c];function g(l,i){return r(),t("div",null,a)}const _=e(n,[["render",g],["__file","vuexsz.html.vue"]]);export{_ as default};
